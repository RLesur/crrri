% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Chrome.R
\name{chrome_execute}
\alias{chrome_execute}
\title{Execute an asynchronous CDP flow with Chrome}
\usage{
chrome_execute(..., .list = NULL, timeouts = 30,
  cleaning_timeout = 30, async = FALSE,
  bin = Sys.getenv("HEADLESS_CHROME"), debug_port = 9222L,
  local = FALSE, extra_args = NULL, headless = TRUE,
  retry_delay = 0.2, max_attempts = 15L)
}
\arguments{
\item{...}{Asynchronous remote flow functions.}

\item{.list}{A list of asynchronous remote flow functions - an alternative to
\code{...}.}

\item{timeouts}{A vector of timeouts applied to each asynchronous function.
Repeated.}

\item{cleaning_timeout}{The delay for cleaning Chrome.}

\item{async}{Is the result a promise? Required for using \code{chrome_execute()}
in Shiny.}

\item{bin}{Character scalar, the path to Chromium or Chrome executable.}

\item{debug_port}{Integer scalar, the Chromium/Chrome remote debugging port.}

\item{local}{Logical scalar, indicating whether the local version of the
protocol (embedded in \code{crrri}) must be used or the protocol must be
fetched \emph{remotely}.}

\item{extra_args}{Character vector, extra command line arguments passed to
Chromium/Chrome.}

\item{headless}{Logical scalar, indicating whether Chromium/Chrome is launched
in headless mode.}

\item{retry_delay}{Number, delay in seconds between two successive tries to
connect to headless Chromium/Chrome.}

\item{max_attempts}{Logical scalar, number of tries to connect to headless
Chromium/Chrome.}
}
\value{
A list with the values of the fulfilled promises for each async function.
If there is only async function, the return value is the value of the
fulfilled promise.
}
\description{
The \code{chrome_execute()} function executes an asynchronous Chrome DevTools
Protocol flow with Chromium/Chrome and turn it into a synchronous function.
An asynchronous remote flow is a function that takes a connection object and
returns a \link[promises:promise]{promise}.
If several functions are passed to \code{chrome_executes()}, their execution is
serial. If one of the asynchronous functions fails, the whole execution also
fails.
}
\examples{
\dontrun{
async_save_as_pdf <- function(url) {
  function(client) {
    Page <- client$Page

    Page$enable() \%...>\% {
      Page$navigate(url = url)
      Page$loadEventFired()
    } \%...>\% {
      Page$printToPDF()
    } \%...>\% {
      .$data \%>\%
        jsonlite::base64_dec() \%>\%
        writeBin(paste0(httr::parse_url(url)$hostname, ".pdf"))
    }
  }
}

save_as_pdf <- function(...) {
  list(...) \%>\%
    purrr::map(async_save_as_pdf) \%>\%
    chrome_execute(.list = .)
}

save_as_pdf("https://www.r-project.org/", "https://rstudio.com/")
}
}
